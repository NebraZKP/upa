#!/usr/bin/env bash

set -x
set -e

# Build
yarn
yarn build

. scripts/shell_setup.sh

# Include the util functions.
. scripts/utils.sh

DUMMY_PW="pw"

# 1 - keyfile to fund
function fund() {
    bal=`upa dev balance --keyfile $1`
    if (( $(echo "${bal} < 100" | bc -l) )) ; then
        upa dev fund --keyfile $1 --amount 100
    fi
}

mkdir -p _test_challenge
pushd _test_challenge
    start_hardhat_node 10545
    echo RPC_ENDPOINT="http://127.0.0.1:10545/" > .env
    echo 'KEYFILE_PASSWORD=' >> .env

    KEYFILE="deployer.key"

    # Create and fund a dummy address (with password)
    if ! [ -e ${KEYFILE} ] ; then
        upa dev ethkeygen --keyfile ${KEYFILE} --password ${DUMMY_PW}
    fi
    fund ${KEYFILE}
    deployer_addr=0x`jq -r .address ${KEYFILE}`

    # Create and fund user address (no password)
    USER_KEYFILE="user.key"
    if ! [ -e ${USER_KEYFILE} ] ; then
        upa dev ethkeygen --keyfile ${USER_KEYFILE}
    fi
    fund ${USER_KEYFILE}

    # Deploy UPA using this key. We set a fixed fee per proof of 20 Wei.
    KEYFILE_PASSWORD=${DUMMY_PW} upa owner deploy \
                    --keyfile ${KEYFILE} \
                    --verifier ${UPA_DIR}/upa/test/data/test.bin \
                    --collateral 10000000000000000000 \
                    --use-test-config \
                    --retries 3

    # Test data:
    #   vk
    TEST_VK=${UPA_DIR}/circuits/src/tests/data/vk.json
    #   single proof
    TEST_SINGLE_PROOF=${UPA_DIR}/circuits/src/tests/data/proof1.json
    #   series of proofs for vk.json
    UNIVERSAL_PROOFS_8=${UPA_DIR}/circuits/src/tests/data/universal_batch_verifier_8_proofs.json
    #   Convert to {circuitId, proof, inputs} format
    CONVERTED_UNIVERSAL_PROOFS_8=universal_batch_verifier_8_proofs_converted.json
    upa convert vk-proofs-inputs \
                    --vk-proofs-inputs-file ${UNIVERSAL_PROOFS_8} \
                    --circuitid-proofs-inputs-file ${CONVERTED_UNIVERSAL_PROOFS_8}

    #  Batch of 4 proofs with different vks and num public inputs.
    UNIVERSAL_PROOFS_4=${UPA_DIR}/circuits/src/tests/data/universal_batch_verifier_4_proofs.json
    # snarkjs data folder directory
    SNARKJS_TEST_DIR=${UPA_DIR}/upa/test/data/snarkjs

    # Extract universal VKs
    for i in {0..3} ; do
        jq ".[$i].vk" ${UNIVERSAL_PROOFS_4} > submit-multi-4.vk-$i.json
    done

    ## Check that no vk was registered via stats
    upa query stats > stats.0
     if ! [ "null"  == "`jq -r .circuitIds stats.0`" ] ; then
        echo "FAILURE: expected registervk to fail"
        exit 1
    fi

    # Register all VKs
    KEYFILE=${KEYFILE} KEYFILE_PASSWORD=${DUMMY_PW} upa registervk ${TEST_VK} \
              --password ${DUMMY_PW} \

    KEYFILE=${KEYFILE} KEYFILE_PASSWORD=${DUMMY_PW} upa registervk submit-multi-4.vk-0.json \
              --password ${DUMMY_PW} \

    KEYFILE=${KEYFILE} KEYFILE_PASSWORD=${DUMMY_PW} upa registervk submit-multi-4.vk-1.json \
              --password ${DUMMY_PW} \
              --wait

    # Check stats and record
    upa query stats > stats.0
    if ! [ "1"  == "`jq -r .nextSubmissionIdx stats.0`" ] ; then
        echo "FAILURE: next_idx expected to be 1"
        exit 1
    fi
    if ! [ "1" == "`jq -r .nextSubmissionIdxToVerify stats.0`" ] ; then
        echo "FAILURE: last_verified expected to be 1"
        exit 1
    fi
    if ! [ "0" == "`jq -r .allocatedFee stats.0`" ] ; then
        echo "FAILURE: allocated_fee expected to be 0"
        exit 1
    fi

    # Check the single proof is valid
    upa dev groth16-verify \
            --proof-file ${TEST_SINGLE_PROOF}

    # Submit a single proof: proof1.json for vk.json
    upa submit-proofs \
           --keyfile ${USER_KEYFILE} \
           --proofs-file ${TEST_SINGLE_PROOF} \
           --proof-ids-file proof_1.pid.json \
           > submit-1.tx.hash

    # Submission of 4 proofs from universal_batch_verifier_4_proofs.json:
    upa submit-proofs \
           --keyfile ${USER_KEYFILE} \
           --proofs-file ${UNIVERSAL_PROOFS_4} \
           --proof-ids-file submit-multi-4.pids.json \
           --wait > submit-multi-4.tx.hash

    # Extract the submissions
    upa get-submission `cat submit-1.tx.hash` > submit-1.submission.json
    upa get-submission `cat submit-multi-4.tx.hash` > submit-multi-4.submission.json

    multi_4_submissionid=`jq -r .submissionId submit-multi-4.submission.json`

    # Allocate the fees for the submitted proofs.
    KEYFILE_PASSWORD=${DUMMY_PW} upa aggregator allocate-aggregator-fee \
           --keyfile ${KEYFILE} \
           --wait

    # Extract proof refs, cids and inputs for the on-chain submission of 4
    for i in {0..3} ; do
        upa compute proof-ref \
               --submission-file submit-multi-4.submission.json \
               --proof-idx $i \
               --proof-ref-file submit-multi-4.ref-$i.json
        jq ".[$i]" ${UNIVERSAL_PROOFS_4} > submit-multi-4.proof-$i.json
    done

     # Check that no proofs are verified yet
    (! upa query is-verified \
            --proof-file ${TEST_SINGLE_PROOF})
    for i in {0..3} ; do
        (! upa query is-verified \
                --proof-file submit-multi-4.proof-$i.json \
                --proof-ref-file submit-multi-4.ref-$i.json)
    done
    ! upa query is-submission-verified ${multi_4_submissionid}

    # Check stats.  Expect 2 submissions, 0 verified.
    upa query stats > stats.1
    if ! [ "3"  == "`jq -r .nextSubmissionIdx stats.1`" ] ; then
        echo "FAILURE: next_idx expected to be 3" #
        exit 1
    fi
    if ! [ "1" == "`jq -r .nextSubmissionIdxToVerify stats.1`" ] ; then
        echo "FAILURE: last_verified expected to be 1"
        exit 1
    fi
    allocated_fee_1=`jq -r .allocatedFee stats.1`
    if [ "0" == "${allocated_fee_1}" ] ; then
        echo "FAILURE: allocated_fee expected to be non-zero"
        exit 1
    fi

    # Submit (fake) aggregated proof (from the deployer) for ONLY
    # the submission of 4, skipping the single proof.
    jq '.[0:4]' submit-multi-4.pids.json > temp_agg.pids.json
    # Flatten proofIds into one array.
    jq -s 'add' temp_agg.pids.json > agg.pids.json

    # Compute the dummy calldata using `compute-final-digest`
    upa aggregator compute-final-digest \
           --proof-ids-file agg.pids.json \
           --calldata-file agg.proof.calldata

    submit_aggregated_proof_flags="\
           --calldata-file agg.proof.calldata \
           --submission submit-multi-4.submission.json \
    "

    # Submit the aggregated proof
    KEYFILE_PASSWORD=${DUMMY_PW} upa aggregator submit-aggregated-proof \
           --keyfile ${KEYFILE} \
           ${submit_aggregated_proof_flags} \
           --wait > agg-proof.hash

    # Check that single proof is still NOT verified.
    (! upa query is-verified \
            --proof-file ${TEST_SINGLE_PROOF})

    # Check proofs from the submission are verified now that the full
    # submission is verified.
    for i in {0..3} ; do
        upa query is-verified \
                --proof-file submit-multi-4.proof-$i.json \
                --proof-ref-file submit-multi-4.ref-$i.json
    done

    # Check by submission Id
    upa query is-submission-verified ${multi_4_submissionid}

    # Check stats.  Expect 2 submissions, 0 verified.
    upa query stats > stats.1
    if ! [ "3"  == "`jq -r .nextSubmissionIdx stats.1`" ] ; then
        echo "FAILURE: next_idx expected to be 3" #
        exit 1
    fi
    if ! [ "3" == "`jq -r .nextSubmissionIdxToVerify stats.1`" ] ; then
        echo "FAILURE: last_verified expected to be 3"
        exit 1
    fi
    allocated_fee_1=`jq -r .allocatedFee stats.1`
    if [ "0" == "${allocated_fee_1}" ] ; then
        echo "FAILURE: allocated_fee expected to be non-zero"
        exit 1
    fi

    upa challenge --keyfile ${USER_KEYFILE} --proofs-file ${TEST_SINGLE_PROOF} > challenge_tx.hash

    # Single proof should now be marked as verified
    upa query is-verified --proof-file ${TEST_SINGLE_PROOF}

    stop_hardhat_node
popd # _test_challenge

set +e
set +x

echo "========================================"
echo "====             PASSED             ===="
echo "========================================"
