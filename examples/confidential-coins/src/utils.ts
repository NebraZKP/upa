import * as ethers from "ethers";
import * as fs from "fs";
import * as path from "path";
import { string, option } from "cmd-ts";
import {
  ConfidentialCoins,
  ConfidentialCoins__factory,
} from "../typechain-types";
import assert from "assert";

export type Option = ReturnType<typeof option>;

export function instance(description?: string | undefined): Option {
  return option({
    type: string,
    long: "instance",
    defaultValue: () => "confidential-coins.instance.json",
    description: description || "confidential-coins instance file",
  });
}

export function circuitWasm(description?: string | undefined): Option {
  return option({
    type: string,
    long: "circuit-wasm",
    defaultValue: () => {
      return findCircuitFile("validatetx_js/validatetx.wasm");
    },
    description:
      description ||
      "The .wasm file for confidential-coins generated by Circom",
  });
}

export function circuitZkey(description?: string | undefined): Option {
  return option({
    type: string,
    long: "circuit-zkey",
    defaultValue: () => {
      return findCircuitFile("validatetx.zkey");
    },
    description: description || "The .zkey file generated by SnarkJS",
  });
}

export function upaInstance(description?: string | undefined): Option {
  return option({
    type: string,
    long: "upa-instance",
    defaultValue: () => `upa.instance.json`,
    description: description || "The UPA instance used by confidential-coins",
  });
}

export function proofOutputFile(description?: string | undefined): Option {
  return option({
    type: string,
    long: "proof-output",
    defaultValue: () => "generated_proofs.json",
    description: description || "Destination file for generated proof data",
  });
}

export function vkFile(description?: string | undefined): Option {
  return option({
    type: string,
    long: "vk-file",
    short: "v",
    defaultValue: () => findCircuitFile("upa_verification_key.json"),
    description: description || "verifying key for confidential-coins",
  });
}

export enum Coin {
  USDT = 0,
  USDC = 1,
  DAI = 2,
}

export type ConfidentialCoinsInstance = {
  /// Address of the ConfidentialCoins contract
  confidentialCoins: string;
  circuitId: string;
};

// Hashed and unhashed balances for each coin.
export type Balances = {
  hashedUSDT: bigint;
  USDT: bigint;
  hashedUSDC: bigint;
  USDC: bigint;
  hashedDAI: bigint;
  DAI: bigint;
};

// Both public and private inputs to the validatetx circuit
export type CircuitInputs = {
  oldSourceCoinBalance: bigint;
  oldSourceCoinBalanceHash: bigint;
  newSourceCoinBalance: bigint;
  newSourceCoinBalanceHash: bigint;
  oldTargetCoinBalance: bigint;
  oldTargetCoinBalanceHash: bigint;
  newTargetCoinBalance: bigint;
  newTargetCoinBalanceHash: bigint;
  transferAmount: bigint;
  transferAmountHash: bigint;
};

export function stringify(balances: Balances) {
  return `USDT: ${balances.USDT}, USDC: ${balances.USDC}, DAI: ${balances.DAI}`;
}

export function loadConfidentialCoinsInstance(
  instance_file: string
): ConfidentialCoinsInstance {
  return JSON.parse(
    fs.readFileSync(instance_file, "ascii")
  ) as ConfidentialCoinsInstance;
}

export function confidentialCoinsFromInstance(
  instance_file: string
): ConfidentialCoins {
  const instance = loadConfidentialCoinsInstance(instance_file);
  return ConfidentialCoins__factory.connect(instance.confidentialCoins);
}

// Must match `ToyHash` in validatetx.circom
export function toyHash(value: bigint): bigint {
  const a = 1234n;
  const b = 2468n;

  return a * value + b;
}

export function toyUnHash(value: bigint): bigint {
  const a = 1234n;
  const b = 2468n;

  return (value - b) / a;
}

export function generateRandomCoinPair() {
  let coins = [Coin.USDT, Coin.USDC, Coin.DAI];
  // Remove one random coin
  coins.splice(Math.floor(Math.random() * 3), 1);

  // 50% chance to reverse order
  if (Math.random() < 0.5) {
    coins = coins.reverse();
  }

  assert(coins.length === 2);
  return coins;
}

export function balancesUninitialized(balances: Balances): boolean {
  return (
    balances.hashedUSDT === 0n &&
    balances.hashedUSDC === 0n &&
    balances.hashedDAI === 0n
  );
}

export async function getOnChainBalances(
  confidentialCoins: ConfidentialCoins,
  wallet: ethers.AbstractSigner
): Promise<Balances> {
  const address = await wallet.getAddress();
  const hashedUSDT = await confidentialCoins.userBalanceHashes(
    address,
    Coin.USDT
  );
  const USDT = toyUnHash(hashedUSDT);

  const hashedUSDC = await confidentialCoins.userBalanceHashes(
    address,
    Coin.USDC
  );
  const USDC = toyUnHash(hashedUSDC);

  const hashedDAI = await confidentialCoins.userBalanceHashes(
    address,
    Coin.DAI
  );
  const DAI = toyUnHash(hashedDAI);

  return { hashedUSDT, USDT, hashedUSDC, USDC, hashedDAI, DAI };
}

export function updateBalances(
  oldBalances: Balances,
  sourceCoin: Coin,
  targetCoin: Coin,
  newSourceCoinBalance: bigint,
  newSourceCoinBalanceHash: bigint,
  newTargetCoinBalance: bigint,
  newTargetCoinBalanceHash: bigint
): Balances {
  const updatedBalances = { ...oldBalances };

  // Update balances based on source coin
  switch (sourceCoin) {
    case Coin.USDT:
      updatedBalances.USDT = newSourceCoinBalance;
      updatedBalances.hashedUSDT = newSourceCoinBalanceHash;
      break;
    case Coin.USDC:
      updatedBalances.USDC = newSourceCoinBalance;
      updatedBalances.hashedUSDC = newSourceCoinBalanceHash;
      break;
    case Coin.DAI:
      updatedBalances.DAI = newSourceCoinBalance;
      updatedBalances.hashedDAI = newSourceCoinBalanceHash;
      break;
    default:
      throw new Error("Invalid source coin");
  }

  // Update balances based on target coin
  switch (targetCoin) {
    case Coin.USDT:
      updatedBalances.USDT = newTargetCoinBalance;
      updatedBalances.hashedUSDT = newTargetCoinBalanceHash;
      break;
    case Coin.USDC:
      updatedBalances.USDC = newTargetCoinBalance;
      updatedBalances.hashedUSDC = newTargetCoinBalanceHash;
      break;
    case Coin.DAI:
      updatedBalances.DAI = newTargetCoinBalance;
      updatedBalances.hashedDAI = newTargetCoinBalanceHash;
      break;
    default:
      throw new Error("Invalid target coin");
  }

  return updatedBalances;
}

export function getBalance(coin: Coin, balances: Balances): bigint {
  switch (coin) {
    case Coin.USDT:
      return balances.USDT;
    case Coin.USDC:
      return balances.USDC;
    case Coin.DAI:
      return balances.DAI;
    default:
      throw new Error("Invalid coin");
  }
}

// Attempt to find a file in the `circuits` directory
function findCircuitFile(filename: string): string {
  // Try the expected locations, based on this file being either in /src
  // or /dist/src directories in the package root.

  let f = path.normalize(path.join(__dirname, "..", "circuits", filename));
  if (!fs.existsSync(f)) {
    f = path.normalize(path.join(__dirname, "..", "..", "circuits", filename));
    if (!fs.existsSync(f)) {
      throw new Error(
        "unable to find " + filename + ".  Specify explicitly with flags."
      );
    }
  }
  return f;
}
